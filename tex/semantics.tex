\section{Instruction semantics}

The~\mintinline{haskell}{Instruction} data type represent the syntax of IAM instructions.
We assign them the semantics by implementing an interpreter
function~\mintinline{haskell}{execute} that performs pattern-matching on data every
constructor of the~\mintinline{haskell}{Instruction} and builds a computation in the
~\mintinline{haskell}{Machine} monad --- a transformer of IAM state. This function
is the heart of the simulation and formal verification framework.

\begin{figure}[H]
\begin{minted}{haskell}
execute :: Instruction -> Machine ()
execute (Halt                ) = executeHalt
execute (Load     rX dmemaddr) = executeLoad     rX dmemaddr
execute (LoadMI   rX dmemaddr) = executeLoadMI   rX dmemaddr
execute (Set      rX simm    ) = executeSet      rX simm
execute (Store    rX dmemaddr) = executeStore    rX dmemaddr
execute (Add      rX dmemaddr) = executeAdd      rX dmemaddr
execute (Jump     simm       ) = executeJump     simm
execute (JumpZero simm       ) = executeJumpZero simm
\end{minted}
\caption{An interpreter of IAM instruction set.}
\label{execute}
\end{figure}

Let us now consider the semantics of some of the instructions.

The simplest thing is halting. If the interpreter sees the halt instruction, it
sets the~\mintinline{haskell}{Halted} flag preventing the following execution.
The~\mintinline{haskell}{writeFlag} does the actual machine state modification,
advancing the clock and setting the flag.

\begin{figure}[H]
\begin{minted}{haskell}
executeHalt :: Machine ()
executeHalt = writeFlag Halted true

writeFlag :: Flag -> SBool -> Machine ()
writeFlag flag value = do
    delay 1
    modify $ \state ->
        state { flags = writeArray (flags state)
                                   (flagId flag)
                                   value }
\end{minted}
\caption{Semantics of the~\mintinline{haskell}{Halt} instruction.}
\label{haltSemantics}
\end{figure}

As a more involved example, let us add the semantics to the addition instruction.
It operates with a register containing a first term and a memory location referring
to the second one. The~\mintinline{haskell}{executeAdd} essentially retrieves the terms,
adds them, places the result to the register, and sets the\mintinline{haskell}{Zero}
flag if the result is zero.

\begin{figure}[H]
\begin{minted}{haskell}
executeAdd :: Register -> MemoryAddress -> Machine ()
executeAdd rX dmemaddr = do
    x <- readRegister rX
    y <- readMemory dmemaddr
    let z = x + y
    writeFlag Zero (z .== 0)
    writeRegister rX z
\end{minted}
\caption{Semantics of the~\mintinline{haskell}{Add} instruction.}
\label{addSemantics}
\end{figure}

An interesting note to make here is that in the implementation of these functions
we are using Haskell as a~\emph{metalanguage}. We are operating the machine as
a puppet master, using the external meta-notions of addition, comparison and let-binding.
From the machine's point of view, we have an unlimited memory and act instantly.
That gives us an unlimited power. Later in this section we'll see how hard it is
to achieve such a power using only IAM's internal entities.

As the most sophisticated example we give here, consider the semantics of the
~\mintinline{haskell}{JumpZero} instruction.It uses SBV's symbolic conditional
operation~\mintinline{haskell}{ite} to test if the~\mintinline{haskell}{Zero} flag
is set, and, if so, modifies the machine's instruction counter by a provide offset.

\begin{figure}[H]
\begin{minted}{haskell}
executeJumpZero :: Byte -> Machine ()
executeJumpZero offset = do
    zeroIsSet <- readFlag Zero
    ic <- instructionCounter <$> get
    let ic' = ite zeroIsSet (ic + fromByte offset) ic
    modify $ \currentState ->
        currentState {instructionCounter = ic'}
\end{minted}
\caption{Semantics of the~\mintinline{haskell}{JumpZero} instruction.}
\label{jumpZeroSemantics}
\end{figure}

The semantics of the conditional jump instruction turns out to be one of the
most sensible parts of a verification framework that relies on symbolical execution.
It is vital to bear in mind the notion of~\emph{symbolic termination}. In our special
case the situation starts to get difficult if the instruction counter value becomes
purely symbolic, i.e. the program termination starts to depend on a symbolic value.
There are ways to control symbolic termination, but current state of implementation of
the verification framework is fragile and relies on the user to prevent the dangerous
situations from happening. Currently, the verification framework uses an external
counter of state transitions that guaranties termination.

The implementations of these three instruction interpreters cover all the interesting
features of the framework's implementation. Please consult to the framework
repository~\cite{IAMGithub} for the full source code.