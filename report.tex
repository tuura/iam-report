%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for
% including it in another document. To do this, you have two options:
%
% 1) Copy/paste everything between \begin{document} and \end{document}
% starting at \begin{titlepage} and paste this into another LaTeX file where you
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and
% move this file to the same directory as the LaTeX file you wish to add it to.
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\title{Title page with logo}
%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{minted}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page

%----------------------------------------------------------------------------------------
%   HEADING SECTIONS
%----------------------------------------------------------------------------------------

% \textsc{\LARGE University Name}\\[1.5cm] % Name of your university/college

%----------------------------------------------------------------------------------------
%   TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Computer Architecture Simulation and Verification}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]

\textsc{\Large A case study on a minimalistic\\ subtracting machine}\\[0.5cm] % Major heading such as course name
% \textsc{\large Experience report}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%   AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
Georgy \textsc{Lukyanov} % Your name
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Supervisor:} \\
Dr. Andrey \textsc{Mokhov} % Supervisor's Name
\end{flushright}
\end{minipage}\\[2cm]

% If you don't want a supervisor, uncomment the two lines below and remove the section above
%\Large \emph{Author:}\\
%John \textsc{Smith}\\[3cm] % Your name

%----------------------------------------------------------------------------------------
%   DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[2cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%   LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[scale=0.5]{logo.png}\\[1cm] % Include a department/university logo - this will require the graphicx package

%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\begin{abstract}
Subtractor is a minimalistic computer architecture developed to be
a case study for computer architecture simulation and verification frameworks
design. To explore the design process of such tools we present a Haskell formalisation of Subtractor including an embedded assembly language, a simulator and a verification back end. We use symbolic execution and automated theorem proving to verify properties of Subtractor programs.

\end{abstract}

\tableofcontents

\section{Introduction}

The Subtractor instruction set architecture is designed to be a case study for
the simulation and formal verification tools development. Thus, the ISA design is mainly driven by the dichotomy between tool's expressiveness and their implementation conciseness.
We want the tools' implementations to be reasonable concise in order to keep focus on the
implementation details and escape the mental overhead of maintaining a large code base. At the same time, the case study ISA must be sophisticated enough to
yield interesting programs with non-trivial properties to be verified.

The Subtractor ISA design was inspired by an extreme case of OISCs~--- one instruction set computers. OISCs have ISAs consisting from one instruction only and are beautiful in their simplicity. But the verification tool implemented for such a simple case would be too degenerate; thus we enriched the architecture with a limited set of additional instructions.

In this report we present the Subtractor instruction set architecture and a Haskell framework for simulation, formal verification and synthesis of Subtractor programs. The framework includes an embedded assembly language and a framework to simulate the Subtracor operation and verify properties of the Subtractor programs. As Subtractor architecture design is mainly driven by our Haskell implementation, we present all the involved concepts using their Haskell encoding. We believe that Haskell notation is clear enough and the chosen manner of presentation will enable us to focus on the formal verification framework implementation.

\section{The Subtractor ISA and its Haskell implementation}

Subtractor is designed to be simple but yet not trivial computer architecture. Since its main purpose is to be a case study for simulation and verification tools design, Substractors design is mainly driven by the dichotomy between tool's expressiveness and conciseness. We aim to explore the methods of development of formal verification tools thus we need a simple yet not trivial case study.

The Subtractor ISA has 4 general purpose registers, 2 flags and 8 commands. It overates 64 bit words as data values and uses 8 bit words as memory addresses. Some instructions expect an 8-bit signed immediate argument.

This section is structured as following: we first consider how the instructions syntax are represented, informally describe the intuitive meaning of each instruction; then we transfer to the model of machine state and execution, gradually building an interpreter for instructions in terms of transitions between Subtractor's states. We continue with the description of an embedded assembly language that enables us to build Subtractor programs reusing the Haskell's notation. The last subsection presents the examples of usage of the developed simulation and formal verification framework.

\subsection{Subtractor instructions}
\label{Instructions}

Let us first consider the data type representing the instructions:

% \begin{figure}
\begin{minted}{haskell}
data Instruction = Load     Register MemoryAddress
                 | LoadMI   Register MemoryAddress
                 | Set      Register SImm8
                 | Store    Register MemoryAddress
                 | Subtract Register MemoryAddress
                 | Jump     SImm8
                 | JumpZero SImm8
                 | Halt
\end{minted}

Before getting to the description of each instruction, let us clarify the other data types involved. The current implementation of the formal verification framework is build on top of Haskell SBV (SMT Based Verification) library~\ref{SBV}. SBV performs symbolic execution of the Subtractor programs, provides a DSL for defining properties to be automatically checked by a SAT/SMT solver. The~\mintinline{haskell}{Register},~\mintinline{haskell}{MemoryAddress} and~\mintinline{haskell}{SImm8} types are internally represented as the symbolic words of appropriate length.

Having that in mind we now can informally describe the behaviour of every instruction. Later in this report we will implement an interpreter for Subtractor assembly language, thus defining an operational semantics for the syntax provided.

Informally, Subtractor instructions have the following meaning:

\begin{itemize}
    \item[\mintinline{haskell}{Load r memaddr}] loads a value from a memory location~\mintinline{haskell}{memaddr} to a register~\mintinline{haskell}{r}.

    \item[\mintinline{haskell}{LoadMI r memaddr}] loads a value from the memory location~\mintinline{haskell}{memaddr} to the register~\mintinline{haskell}{r} using indirect memory access mode, i.e. loading the value from~\mintinline{haskell}{memaddr} and using it as a memory address argument for the \mintinline{haskell}{Load} instruction.

    \item[\mintinline{haskell}{Set r simm8}] loads the 8-bit immediate argument ~\mintinline{haskell}{simm8} to the register~\mintinline{haskell}{r}.

    \item[\mintinline{haskell}{Store r memaddr}] stores a value from the register~\mintinline{haskell}{r} to the memory location~\mintinline{haskell}{memaddr}.

    \item[\mintinline{haskell}{Subtract r memaddr}] subtracts a value placed in the memory location~\mintinline{haskell}{memaddr} from a value contained in the register~\mintinline{haskell}{r}.

    \item[\mintinline{haskell}{Jump simm8}] performs an unconditional jump. Modifies the machine instruction counter (see section~\ref{State}) by~\mintinline{haskell}{simm8} offset.

    \item[\mintinline{haskell}{JumpZero simm8}] performs a conditional jump if the~\mintinline{haskell}{Zero} (see section~\ref{Flags}) flag is set.

    \item[\mintinline{haskell}{Halt}] stops the execution. Sets the~\mintinline{haskell}{Halt} flag (see section~\ref{Flags}).
\end{itemize}

\subsection{Subtractor state and instruction semantics}

Subtractor state and instruction semantics

\subsection{Subtractor assembly language}

To simulate the execution and formally verify properties of the Subtractor programs,
it is construct the programs using the~\mintinline{haskell}{Program} data type, i.e.
listing the pairings of values of type~\mintinline{haskell}{Instruction} with instruction addresses.
However, construction these lists by hand is cumbersome. Luckily, the Haskell programming
language provides powerful facilities for building embedded domain-specific languages, and
we aim to exploit those facilities, concretely  to construct an embedded assembly language.
That will enable us to use Haskell syntax to write programs that later will get translated
to the values of the~\mintinline{haskell}{Program}.

As a teaser, consider an example of an assembly language syntax we are aiming to build:

\begin{minted}{haskell}
swap :: Script
swap = do
    load r0 0
    load r1 1
    store r1 0
    store r0 1
    halt
\end{minted}
\label{syntaxExample}

This simple program implements a swapping of two numbers placed in memory using two
registers. the EDSL's syntax looks exactly like most assembly languages, but it
is still a valid Haskell program. Let us now see how we can implement this with
the help of Haskell's native support for monads.

We use a specialised version of~\mintinline{haskell}{Writer}~\ref{Writer} monad
to implement the assembly language embedding. Consider the following definitions:

\begin{minted}{haskell}
newtype Writer a = Writer {
    runWriter :: [Instruction] -> (a, [Instruction])
}

type Script = Writer ()
\end{minted}

The~\mintinline{haskell}{Writer} monad is designed to be a computation not only
producing a value, but also accumulation a some kind of log during the execution.
In our case, the computation, being a syntactic program constructor, is not supposed
to produce any kind of return values. The feature we really exploit is the logging one,
i.e. each step of the monadic computation will extend the accumulating log with a
value of type~\mintinline{haskell}{Instruction}. At the end of the day, the log will
contain the list of instructions.

We provide a convenient combinator~\mintinline{haskell}{write}, taking an instruction
and adding it to a~\mintinline{haskell}{Script}.

\begin{minted}{haskell}
write :: Instruction -> Script
write i = Writer (\p -> ((), i:p))
\end{minted}

We have almost implemented all the facilities to write a program~\ref{syntaxExample}.
The only things left are the convenience combinators for embedding of every instruction.
As an example consider the embedding of~\mintinline{haskell}{halt}
and~\mintinline{haskell}{load} instructions:

\begin{minted}{haskell}
halt :: Script
halt = write Halt

load :: Register -> MemoryAddress -> Script
load rX dmemaddr = write (Load rX dmemaddr)
\end{minted}

That is it, these embedder-functions just call the~\mintinline{haskell}{write}
combinator to append the corresponding values of the~\mintinline{haskell}{Instruction}
data type to the~\mintinline{haskell}{Script}.

Now we are able to use the power of Haskell's~\mintinline{haskell}{do}-notation to
build Subtractor assembly programs. The last bit is translating
the~\mintinline{haskell}{Script}'s to~\mintinline{haskell}{Program}'s. We implement the
translation with the following function:

\begin{minted}{haskell}
assemble :: Script -> Program
assemble s = zip [0..] prg
  where
    prg = reverse $ snd $ runWriter s []
\end{minted}

We extract the list of instructions from the~\mintinline{haskell}{Writer} computation
and pair each instruction with an instruction code. As a usage instance, consider the
translation of the previously considered swapping program:

\begin{minted}{haskell}
[ (0, Load  0 0 )
, (1, Load  1 1 )
, (2, Store 1 0)
, (3, Store 0 1)
, (4, Halt     )
]
\end{minted}

Haskell provides a variety of methods for EDSLs construction.
We used one of them to build an embedding of Subtractor assembly language.
With only a few lines of code we recruited the power of standard Haskell's
~\mintinline{haskell}{do}-notation to write programs in our custom language and
translate it to our custom data type.

In the next subsection, we are going to build a simulation and formal verification
framework to observe the results of programs' executions and verify their properties.

\subsection{Simulating and formally verifying Subtractor programs}

Simulating and formally verifying Subtractor programs

% \caption{Subtractor instructions}
% \end{figure}

% \section{Embedding Subtractor in Haskell}

% \subsection{Basics}

% \subsection{Machine state}

% We represent the Subtractor machine state as a record type.

% \begin{minted}{haskell}
% data MachineState = MachineState
%     { registers           :: RegisterBank
%     , instructionCounter  :: InstructionAddress
%     , instructionRegister :: Instruction
%     , flags               :: Flags
%     , memory              :: Memory
%     , program             :: Program
%     , clock               :: Clock
%     }
% \end{minted}

% \subsection{Machine operation}

% \subsection{Assembly language syntax}

% We define the program as a value of type~\mintinline{haskell}{Script}. Since~\mintinline{haskell}{Script} is a monad, we can use Haskell's~\mintinline{haskell}{do}-notation to write the program code.

% \begin{minted}{haskell}
% type Script = Writer [Instruction] ()
% \end{minted}

% \begin{minted}{haskell}
% load :: Register -> MemoryAddress -> Script
% load rX dmemaddr = tell [Load rX dmemaddr]

% set :: Register -> SImm8 -> Script
% set rX simm = tell [Set rX simm]

% store :: Register -> MemoryAddress -> Script
% store rX dmemaddr = tell [Store rX dmemaddr]

% subtract :: Register -> MemoryAddress -> Script
% subtract rX dmemaddr = tell [Subtract rX dmemaddr]

% jump :: SImm10 -> Script
% jump simm = tell [Jump simm]

% jumpZero :: SImm10 -> Script
% jumpZero simm = tell [JumpZero simm]

% halt :: Script
% halt = tell [Halt]
% \end{minted}

% \subsection{Assembly language semantics}

% The Subtractor program semantics is essentially a state transformer. Every instruction execution takes a current machine state, transforms it in a specified way and yields a modified state. Haskell provides a dedicated abstraction to encode this kind of behavior~--- a state monad~\cite{stateMonad}.

% \begin{minted}{haskell}
% newtype Machine a = Machine { runMachine :: State MachineState a }
%     deriving (Functor, Applicative, Monad, MonadState MachineState)
% \end{minted}

% The instruction execution process is implemented as an monadic action parametrized by a value of the~\mintinline{haskell}{Instruction} data type. The~\mintinline{haskell}{execute} function is essentially an interpreter, assigning the semantics to every Subtractor instruction.

% \begin{minted}{haskell}
% execute :: Instruction -> Machine ()
% execute (Halt                ) = writeFlag Halted true
% execute (Load     rX dmemaddr) = readMemory dmemaddr >>= writeRegister rX
% execute (Set      rX simm    ) = (writeRegister rX $ fromSImm8 simm)
% execute (Store    rX dmemaddr) = readRegister rX >>= writeMemory dmemaddr
% execute (Subtract rX dmemaddr) = do
%     x <- readRegister rX
%     y <- readMemory dmemaddr
%     let z = x - y
%     writeFlag Zero (z .== 0)
%     writeRegister rX z
% execute (Jump     simm          ) =
%     modify $ \currentState ->
%         currentState {instructionCounter =
%             instructionCounter currentState + fromSImm10 simm}
% execute (JumpZero simm          ) = do
%     zeroIsSet <- readFlag Zero
%     ic <- instructionCounter <$> get
%     let ic' = ite zeroIsSet (ic + fromSImm10 simm) ic
%     modify $ \currentState ->
%         currentState {instructionCounter = ic'}
% \end{minted}

% \section{Simulation and verification back end}

% The developed framework provides a work flow for writing Subtractor assembly programs, simulating their execution with concrete values and provides a prototype of program verification facilities by means of symbolical execution of Subtractor programs.

% To get started, let us consider a simple program swapping two numbers located in memory.

% \begin{minted}{haskell}
% swap :: Script
% swap = do
%     load r0 0
%     load r1 1
%     store r1 0
%     store r0 1
%     halt
% \end{minted}

% The program consist from only 5 commands. The first two load the values from memory to two registers and the the second two stores them with locations swapped.

\section{Conclusion and future work}

The verification part of the developed framework still requires a lot of work to be usable. Currently it allow to verify only basic properties of short programs. One of the closest development goals is to enable it to verify programs with loops.

\end{document}