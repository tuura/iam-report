%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University Assignment Title Page
% LaTeX Template
% Version 1.0 (27/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% WikiBooks (http://en.wikibooks.org/wiki/LaTeX/Title_Creation)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Instructions for using this template:
% This title page is capable of being compiled as is. This is not useful for
% including it in another document. To do this, you have two options:
%
% 1) Copy/paste everything between \begin{document} and \end{document}
% starting at \begin{titlepage} and paste this into another LaTeX file where you
% want your title page.
% OR
% 2) Remove everything outside the \begin{titlepage} and \end{titlepage} and
% move this file to the same directory as the LaTeX file you wish to add it to.
% Then add \input{./title_page_1.tex} to your LaTeX file where you want your
% title page.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\title{Title page with logo}
%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{minted}

\usepackage[
  backend=biber,
  hyperref=auto,
  language=auto,
  sorting=none,
  citestyle=gost-numeric,
  bibstyle=gost-numeric,
]{biblatex}
\addbibresource{biblio.bib}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center % Center everything on the page

%----------------------------------------------------------------------------------------
%   HEADING SECTIONS
%----------------------------------------------------------------------------------------

% \textsc{\LARGE University Name}\\[1.5cm] % Name of your university/college

%----------------------------------------------------------------------------------------
%   TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Computer Architecture Simulation and Verification}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]

\textsc{\Large A case study on a minimalistic\\ subtracting machine}\\[0.5cm] % Major heading such as course name
% \textsc{\large Experience report}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%   AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Author:}\\
Georgy \textsc{Lukyanov} % Your name
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Supervisor:} \\
Dr. Andrey \textsc{Mokhov} % Supervisor's Name
\end{flushright}
\end{minipage}\\[2cm]

% If you don't want a supervisor, uncomment the two lines below and remove the section above
%\Large \emph{Author:}\\
%John \textsc{Smith}\\[3cm] % Your name

%----------------------------------------------------------------------------------------
%   DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[2cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%   LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics[scale=0.5]{logo.png}\\[1cm] % Include a department/university logo - this will require the graphicx package

%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}

\begin{abstract}
Subtractor is a minimalistic computer architecture developed to be
a case study for computer architecture simulation and verification frameworks
design. To explore the design process of such tools we present a Haskell formalisation of Subtractor including an embedded assembly language, a simulator and a verification back end. We use symbolic execution and automated theorem proving to verify properties of Subtractor programs.

\end{abstract}

\tableofcontents

\section{Introduction}

The Subtractor instruction set architecture is designed to be a case study for
the simulation and formal verification tools development. Thus, the ISA design is mainly driven by the dichotomy between tool's expressiveness and their implementation conciseness.
We want the tools' implementations to be reasonable concise in order to keep focus on the
implementation details and escape the mental overhead of maintaining a large code base. At the same time, the case study ISA must be sophisticated enough to
yield interesting programs with non-trivial properties to be verified.

The Subtractor ISA design was inspired by an extreme case of OISCs~--- one instruction set computers. OISCs have ISAs consisting from one instruction only and are beautiful in their simplicity. But the verification tool implemented for such a simple case would be too degenerate; thus we enriched the architecture with a limited set of additional instructions.

In this report we present the Subtractor instruction set architecture and a Haskell framework for simulation, formal verification and synthesis of Subtractor programs. The framework includes an embedded assembly language and a framework to simulate the Subtracor operation and verify properties of the Subtractor programs. As Subtractor architecture design is mainly driven by our Haskell implementation, we present all the involved concepts using their Haskell encoding. We believe that Haskell notation is clear enough and the chosen manner of presentation will enable us to focus on the formal verification framework implementation.

\section{The Subtractor ISA and its Haskell implementation}

Subtractor is designed to be simple but yet not trivial computer architecture. Since its main purpose is to be a case study for simulation and verification tools design, Substractors design is mainly driven by the dichotomy between tool's expressiveness and conciseness. We aim to explore the methods of development of formal verification tools thus we need a simple yet not trivial case study.

The Subtractor ISA has 4 general purpose registers, 2 flags and 8 commands. It overates 64 bit words as data values and uses 8 bit words as memory addresses. Some instructions expect an 8-bit signed immediate argument.

This section is structured as following: we first consider how the instructions syntax are represented, informally describe the intuitive meaning of each instruction; then we transfer to the model of machine state and execution, gradually building an interpreter for instructions in terms of transitions between Subtractor's states. We continue with the description of an embedded assembly language that enables us to build Subtractor programs reusing the Haskell's notation. The last subsection presents the examples of usage of the developed simulation and formal verification framework.

\subsection{Subtractor instructions}
\label{Instructions}

Let us first consider the data type representing the instructions:

% \begin{figure}
\begin{minted}{haskell}
data Instruction = Load     Register MemoryAddress
                 | LoadMI   Register MemoryAddress
                 | Set      Register SImm8
                 | Store    Register MemoryAddress
                 | Subtract Register MemoryAddress
                 | Jump     SImm8
                 | JumpZero SImm8
                 | Halt
\end{minted}

Before getting to the description of each instruction, let us clarify the other data types involved. The current implementation of the formal verification framework is build on top of Haskell SBV (SMT Based Verification) library~\ref{SBV}. SBV performs symbolic execution of the Subtractor programs, provides a DSL for defining properties to be automatically checked by a SAT/SMT solver. The~\mintinline{haskell}{Register},~\mintinline{haskell}{MemoryAddress} and~\mintinline{haskell}{SImm8} types are internally represented as the symbolic words of appropriate length.

Having that in mind we now can informally describe the behaviour of every instruction. Later in this report we will implement an interpreter for Subtractor assembly language, thus defining an operational semantics for the syntax provided.

Informally, Subtractor instructions have the following meaning:

\begin{itemize}
    \item[\mintinline{haskell}{Load r memaddr}] loads a value from a memory location~\mintinline{haskell}{memaddr} to a register~\mintinline{haskell}{r}.

    \item[\mintinline{haskell}{LoadMI r memaddr}] loads a value from the memory location~\mintinline{haskell}{memaddr} to the register~\mintinline{haskell}{r} using indirect memory access mode, i.e. loading the value from~\mintinline{haskell}{memaddr} and using it as a memory address argument for the \mintinline{haskell}{Load} instruction.

    \item[\mintinline{haskell}{Set r simm8}] loads the 8-bit immediate argument ~\mintinline{haskell}{simm8} to the register~\mintinline{haskell}{r}.

    \item[\mintinline{haskell}{Store r memaddr}] stores a value from the register~\mintinline{haskell}{r} to the memory location~\mintinline{haskell}{memaddr}.

    \item[\mintinline{haskell}{Subtract r memaddr}] subtracts a value placed in the memory location~\mintinline{haskell}{memaddr} from a value contained in the register~\mintinline{haskell}{r}.

    \item[\mintinline{haskell}{Jump simm8}] performs an unconditional jump. Modifies the machine instruction counter (see section~\ref{State}) by~\mintinline{haskell}{simm8} offset.

    \item[\mintinline{haskell}{JumpZero simm8}] performs a conditional jump if the~\mintinline{haskell}{Zero} (see section~\ref{Flags}) flag is set.

    \item[\mintinline{haskell}{Halt}] stops the execution. Sets the~\mintinline{haskell}{Halt} flag (see section~\ref{Flags}).
\end{itemize}

\subsection{Subtractor state and instruction semantics}

Subtractor state and instruction semantics

\subsection{The assembly language}

To simulate the execution and formally verify properties of the IAM programs,
it is possible to construct the programs using the~\mintinline{haskell}{Program} data type, i.e.
listing the pairings of values of type~\mintinline{haskell}{Instruction} and instruction addresses.
However, constructing these lists by hand is cumbersome. Luckily, the Haskell programming
language provides powerful facilities for building embedded domain-specific languages, and
we aim to exploit those facilities to construct an embedded assembly language.
That will enable us to use Haskell syntax to write programs that later will get translated
to the values of the~\mintinline{haskell}{Program} data type.

\subsubsection{An example program}

As a teaser, consider an example of an assembly language syntax we are aiming to build:

\begin{figure}[H]
\begin{minted}{haskell}
sumArray :: Script
sumArray = do
    load r0 0       -- sum := 0, sum accumulator
    load r2 254     -- i := n,   loop counter
    loop <- label
    store r2 255    -- store the value of i to use it for accessing the array
    loadMI r1 255   -- load a[i]
    store r1 254    -- put a[i] to cell 254
    add r0 254      -- sum := sum + a[i]
    add r2 253      -- i := i - 1
    jumpZero 1      -- if i == 0 then halt
    goto loop       -- else continue the loop
    halt
\end{minted}
\caption{Sum an array of numbers}
\label{syntaxExample}
\end{figure}

This program sums an sequence of numbers located in the memory. We will use this program as
our running example through the rest of the report, simulating the execution of the program
and verifying its correctness. Note that the EDSL's syntax looks exactly like the ones of most
assembly languages, but it still is a valid Haskell program. The only
divergence is the label declaration syntax. Let us now see how we can implement
all this with the help of Haskell's native support for monads.

\subsubsection{Using~\mintinline{haskell}{Writer} to write assembly}

We use a specialised version of~\mintinline{haskell}{Writer} monad
to implement the assembly language embedding.

Please note, that we do not describe the actual monad instance for
the~\mintinline{haskell}{Writer} data type, providing only an intuition.
Please, refer to a Haskell textbook~\cite{Lipovaca:2011:LYH:2018642} for an
extensive tutorial.

Consider the following definitions:

\begin{figure}[H]
\begin{minted}{haskell}
newtype Writer a = Writer {
    runWriter :: [Instruction] -> (a, [Instruction])
}

type Script = Writer ()
\end{minted}
\end{figure}

The~\mintinline{haskell}{Writer} monad is designed to be a computation not only
producing a value, but also accumulation a some kind of a log during the execution.
In our case, the computation, being a syntactic program constructor, is not supposed
to produce any kind of return values. The feature we really exploit is the logging one,
i.e. each step of the monadic computation will extend the accumulating log with a
value of type~\mintinline{haskell}{Instruction}. At the end of the day, the log will
contain the list of instructions.

We provide a convenient combinator~\mintinline{haskell}{write}, taking an instruction
and appending it to a~\mintinline{haskell}{Script}.

\begin{figure}[H]
\begin{minted}{haskell}
write :: Instruction -> Script
write i = Writer (\p -> ((), i:p))
\end{minted}
\end{figure}

We have almost implemented all the facilities to write the program~\ref{syntaxExample}.
The only things left are the convenience combinators for embedding of every instruction
and labels jumps.

Let us start with the instructions embeddings. As an example, consider the
embedding of~\mintinline{haskell}{halt} and~\mintinline{haskell}{load} instructions:

\begin{figure}[H]
\begin{minted}{haskell}
halt :: Script
halt = write Halt

load :: Register -> MemoryAddress -> Script
load rX dmemaddr = write (Load rX dmemaddr)
\end{minted}
\end{figure}

That is it, these embedder-functions just call the~\mintinline{haskell}{write}
combinator to append the corresponding values of the~\mintinline{haskell}{Instruction}
data type to the~\mintinline{haskell}{Script}. The rest of the instructions may
be embedded similarly.

\subsubsection{Jumping to labels}

Now we need to implement labels and the~\mintinline{haskell}{goto} command. The machine
instruction set has a conditional and unconditional jump instructions, but using them
directly requires to calculate the instruction counter offset by hand. This is possible,
but introduces an unnecessary mental overhead for the programmer. Fortunately, we
can extend the assembly language syntax with labels and the~\mintinline{haskell}{goto}
command on the level of syntax, no semantics modification required.

The key idea is to represent labels as values the position of the instruction in the
instruction list.

\begin{figure}[H]
\begin{minted}{haskell}
label :: Writer Label
label = Writer (\p -> (Label (length p), p))
\end{minted}
\caption{Labels are the instructions' indices}
\label{label}
\end{figure}

The~\mintinline{haskell}{goto} command now may be implemented using the unconditional
jump with an offset calculated as a difference between the current position in the program and
one associated with label.

\begin{figure}[H]
\begin{minted}{haskell}
goto :: Label -> Script
goto (Label there) = do
    Label here <- label
    let offset = fromIntegral (there - here - 1)
    jump offset
\end{minted}
\caption{Syntactic~\mintinline{haskell}{goto} implementation}
\label{goto}
\end{figure}

The syntactic~\mintinline{haskell}{goto} implementation is free: we do not need
to extend the semantics of the language to add it. However, the current implementation
has a flaw. There is no label hoisting, i.e. no possibility to go to a label declared later
in the program. Therefore, it is necessary to use the explicit offset jumps to
go forward.

\subsubsection{Assembling the~\mintinline{haskell}{Program}}

Now we are able to use the power of Haskell's~\mintinline{haskell}{do}-notation to
build Subtractor assembly programs. The last bit is translating
the~\mintinline{haskell}{Script}'s to~\mintinline{haskell}{Program}'s. We implement the
translation with the following function:

\begin{figure}[H]
\begin{minted}{haskell}
assemble :: Script -> Program
assemble s = zip [0..] prg
  where
    prg = reverse $ snd $ runWriter s []
\end{minted}
\caption{Assemble scripts to programs.}
\end{figure}

We extract the list of instructions from the~\mintinline{haskell}{Writer} computation
and pair each instruction with an instruction code. As an usage instance, consider the
translation of the previously considered summation program:

\begin{figure}[H]
\begin{minted}{haskell}
[ (0, Load     0  0  )
, (1, Load     2  254)
, (2, Store    2  255)
, (3, LoadMI   1  255)
, (4, Store    1  254)
, (5, Add      0  254)
, (6, Add      2  253)
, (7, JumpZero 1     )
, (8, Jump     -7    )
, (9, Halt           )
]
\end{minted}
\caption{The compiled program.}
\end{figure}

Again, note that the labels implementation is purely syntactical and the resulting
program contains explicit offset jumps.

\subsubsection{Conclusion}

Haskell provides a variety of methods for EDSLs construction.
We used one of them to build an embedding of IAM assembly language.
With only a few lines of code we recruited the power of standard Haskell's
~\mintinline{haskell}{do}-notation to write programs in our custom language and
translate it to our custom data type.

In the next subsection, we are going to build a simulation and formal verification
framework to observe the results of programs' executions and verify their properties.

\subsection{Simulating and formally verifying programs}



\section{Conclusion and future work}

The verification part of the developed framework still requires a lot of work to be usable. Currently it allow to verify only basic properties of short programs. One of the closest development goals is to enable it to verify programs with loops.

% Печать списка литературы (библиографии)
\printbibliography[
     heading=bibintoc %
    , title=Bibliography % если хочется это слово
]

\end{document}